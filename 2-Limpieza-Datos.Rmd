---
title: "2. Limpieza Datos"
author: "Grupo 4: Guillermo Cadavid, Pau Pous"
output: html_document
date: "2025-01-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(hms)
library(readr)
library(lubridate)
library(stringr)
library(tidyverse)
library(ggExtra)
library(mltools)
library(data.table)
library(GGally)
library(kableExtra)
```

## Obtención y carga de los Datos

Descompression y carga del fichero

//TO ADD - descompression

```{r read_data, include = FALSE}
column_names <- c("ip", "timestamp", "peticion", "codigo", "bytes")
column_types <- cols(
  ip = col_character(),
  timestamp = col_character(),
  peticion = col_character(),
  codigo = col_character(),
  bytes = col_double()
)

raw_data <- read_delim("data/epa-http.csv",
  col_names = column_names,
  col_types = column_types,
  show_col_types = FALSE,
  trim_ws = TRUE
)
```


Una vez leido el fichero hemos obtenido los siguientes datos:

| Nombre | Tipo | Descripcion |
|---|---|---|---|---|
| ip |  Character | Direccion IP o URL de la peticion  |
| timestamp  |  DateTime |  Fechan cuando se realiza la peticion | 
| peticion  | Character  | La peticion en si, con el metodo, recurso y protocolo utilizado   |
| codigo | Character | Codigo de la respuesta de la peticion |
| bytes | Numeric | Tamano en bytes de la peticion |

A continuacion una muestra, head(), de los datos obtenidos:

```{r show_head_raw_data, include=TRUE, echo=FALSE}
head(raw_data) %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("responsive"))

```

## Limpieza de los Datos

A continuacion se muestran, un head, de los datos una vez limpiado. A demas se han transformado y anadido una serie de columnas que pueden ser utiles para el analisis


**Columnas anadidas una vez limpiadas**

| Nombre | Tipo | Descripcion |
|---|---|---|---|---|
| ip   |  Character | Direccion IP o URL de la peticion  |
| timestamp  |  DateTime/POSIXct |  Fechan cuando se realiza la peticion | 
| numeric_timestamp  |  Numeric |  Fechan cuando se realiza la peticion en formato numero | 
| peticion  | Character  | La peticion en si, con el metodo, recurso y protocolo utilizado |
| metodo | Factor | Metodo usado por la peticion, GET, POST, DELETE, HEAD |
| recurso | Character | Contenido pedido por la peticion |
| protocolo | Factor | Protocolo usado por la peticion HTTP/1.0 |
| bytes | Numeric | Tamano en bytes de la peticion |
| is_error | Factor | Codigo de la respuesta de la peticion |
| is_image | Factor | Tamano en bytes de la peticion |
| domain_extension | Factor | Extension del deominio de la IP, si no es una URL se assigna 'none' |
| domain | Factor | Dominio de la IP, si no es una URL se assigna 'none' |

**Muestra de los datos limpiados**

```{r clean_and_transform_data, include = TRUE, echo = FALSE}
clean_data <- raw_data %>%
  na.omit() %>%
  mutate(codigo = as.factor(codigo)) %>%
  mutate(timestamp = ymd_hms(paste("2024-11", gsub("\\[|\\]", "", timestamp)), truncated = 3)) %>%
  mutate(numeric_timestamp = as.numeric(timestamp)) %>%
  separate(peticion, c("metodo", "recurso", "protocolo"), sep = " ", remove = FALSE) %>%
  mutate(metodo = as.factor(metodo)) %>%
  mutate(protocolo = as.factor(protocolo)) %>%
  mutate(is_error = ifelse(codigo == "200", FALSE, TRUE)) %>%
  mutate(is_image = str_detect(recurso, ".gif|.png|.jpg|.jpeg")) %>%
  mutate(
    domain_extension = case_when(
      grepl("^\\d{1,3}(\\.\\d{1,3}){3}$", ip) ~ "none",
      grepl("\\.", ip) ~ sub(".*\\.(.*)$", "\\1", ip),
      TRUE ~ ""
    ),
    domain_extension = as.factor(domain_extension)
  ) %>%
  mutate(
    domain = case_when(
      grepl("^\\d{1,3}(\\.\\d{1,3}){3}$", ip) ~ "none",
      grepl("\\.", ip) ~ sub(".*?([a-z0-9\\-]+\\.[a-z]+)$", "\\1", ip),
      TRUE ~ "" 
    ),
    domain = as.factor(domain) # Convert to factor
  )

head(clean_data) %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("responsive"))
```

### Analisis de Datos

```{r analisis_datos_data, include = FALSE}

# Frequencia de peticiones por metodo
freq_by_method <- clean_data %>%
  count(metodo, name = "freq")

# Frequencia de peticiones por metodo, solo imagenes
freq_by_method_just_images <- clean_data %>%
  filter(is_image) %>%
  count(metodo, name = "freq")

```

**Frequencia de peticiones por metodo**
```{r analisis_datos_output_1, include = TRUE, echo = FALSE}

freq_by_method %>%
  arrange(desc(freq)) %>%
  kbl(
    col.names = c("Metodfo", "Frequencia"),
    align = "lc",
  ) %>%
  kable_styling(bootstrap_options = c("responsive"))

#ggplot() +
#  geom_col(data = freq_by_method, aes(x = metodo, y = freq), position = "identity") +
#  labs(
#    title = "Frequencia de peticiones por metodo",
#    x = "Metodo",
#    y = "Frequencia",
#    fill = "Tipo de enlace"
#  ) +
#  theme(legend.position = "right")

```

**Frequencia de peticiones por metodo, solo imagenes**
```{r analisis_datos_output_2, include = TRUE, echo = FALSE}

freq_by_method_just_images %>%
  arrange(desc(freq)) %>%
  kbl(
    col.names = c("Metodo", "Frequencia"),
    align = "lc",
  ) %>%
  kable_styling(bootstrap_options = c("responsive"))

#ggplot() +
#  geom_col(data = freq_by_method_just_images, aes(x = metodo, y = freq), position = "identity") #+
#  labs(
#    title = "Frequencia de peticiones por metodo, solo imagenes",
#    x = "Metodo",
#    y = "Frequencia",
#    fill = "Tipo de enlace"
#  ) +
#  theme(legend.position = "right")

```

### Visualizacion de Datos

**Grafico 1**

Distribucion del total de bytes descargados los differentes dominios, solo para las peticiones que han sido correctas (200).

```{r graphics_1, include = TRUE, echo = FALSE}
by_size <- clean_data %>%
  filter(codigo == "200") %>%
  group_by(domain_extension) %>%
  summarise(total_kb = sum(bytes) / 1024)

ggplot() +
  geom_col(data = by_size, aes(x = total_kb, y = domain_extension, fill = "1")) +
  labs(
    title = "Distribucion de tamano de peticiones por extension de dominio",
    x = "KBytes",
    y = "Extension"
  ) +
  theme(legend.position = "none")
```

**Grafico 2**

Comparacion de los codigos de respuesta devueltos por las peticiones

```{r graphics_2, include = TRUE, echo = FALSE}
clean_data %>%
  count(codigo) %>%
  ggplot(aes(x = "", y = n, fill = codigo)) +
    geom_col(width = 1, color = "white") +
    coord_polar("y", start = 0) +
    labs(
      title = "Distribucion codigos de Respuesta",
      fill  = "Codigo"
    ) +
    theme_void() +
    theme(legend.position = "right")
```

**Peticiones en el tiempo**

```{r graphics_3, include = TRUE, echo = FALSE}
requests_timeline <- clean_data %>%
  mutate(timestamp = round_date(timestamp, unit = "minute")) %>%
  count(timestamp, name = "total")

ggplot() +
  geom_bar(data = requests_timeline, aes(x = timestamp, y = total), width = 0.1, stat = "identity", color = "black")
```

## Clustering de Datos

**8. Utilizando un algoritmo de aprendizaje no supervisado, realizad un
análisis de clústering con k-means para los datos del servidor.**


```{r k_means, include = TRUE, echo = FALSE}
k_data <- clean_data %>%
  mutate(is_image = ifelse(is_image, 1, 0)) %>%
  mutate(is_error = ifelse(is_error, 1, 0)) %>%
  mutate(recurso = str_length(recurso)) %>%
  select(recurso, bytes, metodo, codigo, is_error, is_image, numeric_timestamp, domain_extension)

one_hot_data <- one_hot(as.data.table(k_data), sparsifyNAs = TRUE)

kmeans_output <- kmeans(x = one_hot_data, centers = 3, nstart = 25)

one_hot_data$cluster <- as.character(kmeans_output$cluster)

# ggpairs(one_hot_data, aes(color = cluster, alpha = 0.5), progress = FALSE)

ggplot() +
  geom_point(
    data = one_hot_data,
    mapping = aes(x = bytes, y = numeric_timestamp, colour = cluster)
  )

ggplot() +
  geom_point(
    data = one_hot_data,
    mapping = aes(x = recurso, y = bytes, colour = cluster)
  )

ggplot() +
  geom_point(
    data = one_hot_data,
    mapping = aes(x = is_image, y = recurso, colour = cluster)
  )
```
